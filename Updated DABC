{
  "cells": [
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "-EHPspOgTWnJ"
      },
      "outputs": [],
      "source": [
        "class PluckerRelations:\n",
        "    def __init__(self,edge_net,dim_I, dim_J):\n",
        "        self.edge_net = edge_net\n",
        "        self.edges = [edge_net[key] for key in edge_net]\n",
        "        self.n = len(self.edges)\n",
        "        self.dim1 = max([max([self.edges[i][j][0] for j in range(len(self.edges[i]))]) for i in range(len(self.edges))])+1\n",
        "        #highest starting edge, first dimension\n",
        "        self.dim2 = max([max([self.edges[i][j][1] for j in range(len(self.edges[i]))]) for i in range(len(self.edges))])+1\n",
        "        #highest ending edge, first dimension\n",
        "        self.dim_I = dim_I\n",
        "        self.dim_J = dim_J\n",
        "        self.B_i = [i for i in range(self.dim1)]\n",
        "        self.B_j = [i for i in range(self.dim2)]\n",
        "        self.minors = {'i':[], 'j':[]}\n",
        "        self.minor_tracking = {'i':[], 'j':[]}\n",
        "        self.terms = []\n",
        "        self.term_tracking = []\n",
        "\n",
        "    def cell_compatibility(self, S_1, S_2):\n",
        "        for i in S_1:\n",
        "            for j in range(n-1):\n",
        "                if (i+(pl.u(pl.t)*(j)) not in S_2):\n",
        "                    return False\n",
        "        else:\n",
        "            return True\n",
        "\n",
        "\n",
        "    def get_nonzero_coords(self,v):\n",
        "        def get_increasing_diag_indices(start_index, num_entries):\n",
        "            return [(start_index[0]+i, start_index[1]+i) for i in range(num_entries)]\n",
        "\n",
        "        if v != self.n:\n",
        "            if self.n == 2:\n",
        "                return get_increasing_diag_indices((0,0),self.u(self.t))\n",
        "            else:\n",
        "                starting_index = ((v-1)*self.u(self.t))\n",
        "                return get_increasing_diag_indices((0, starting_index), self.u(self.t))\n",
        "        else:\n",
        "            if self.n == 2:\n",
        "                return get_increasing_diag_indices((0,1), self.u(self.t))\n",
        "            elif self.n == 3:\n",
        "                indices = []\n",
        "                starting_index = self.u(self.t-1)\n",
        "                for i in range(1,self.t+1):\n",
        "                    indices += get_increasing_diag_indices((0, starting_index),self.u(self.t-i))\n",
        "                    starting_index += 2*self.u(self.t-i)\n",
        "                starting_index += 2\n",
        "                indices += get_increasing_diag_indices((0, starting_index),self.u(self.t))\n",
        "                return indices\n",
        "            else:\n",
        "                indices = []\n",
        "                starting_index = self.u(self.t-1)\n",
        "                for i in range(1,self.t+1):\n",
        "                    indices += get_increasing_diag_indices((0, starting_index),self.u(self.t-i))\n",
        "                    starting_index += self.u(self.t-i)\n",
        "                    for _ in range(self.n-3):\n",
        "                        starting_index+= self.u(self.t+1-i)\n",
        "                        indices += get_increasing_diag_indices((0,starting_index),self.u(self.t-i))\n",
        "                        starting_index += self.u(self.t-i)\n",
        "                    starting_index += self.u(self.t-i)\n",
        "                starting_index += 2\n",
        "                indices += get_increasing_diag_indices((0, starting_index),self.u(self.t))\n",
        "                return indices\n",
        "\n",
        "    def generate_succesor_closed_graph(self):\n",
        "        edges = [{i:[] for i in range(self.dim1)} for _ in range(self.n)]\n",
        "        for v in range(self.n):\n",
        "            for x,y in self.edges[v]:\n",
        "                edges[v][x].append(y)\n",
        "\n",
        "        return edges\n",
        "\n",
        "    def display_succesor_graph(self,S_1, S_2):\n",
        "        edges = self.generate_succesor_closed_graph()\n",
        "        TeX = \"\\\\begin{tikzpicture}\"\n",
        "        TeX += \"[cell_node/.style={circle, draw=black!60, minimum size=2mm,inner sep=3pt},\"\n",
        "        TeX += \",non_cell_node/.style={draw=white!60, minimum size=5mm, inner sep=3pt}]\\n\"\n",
        "        set_2_vertices = []\n",
        "        for edge_set in edges:\n",
        "            for key in edge_set:\n",
        "                for vertex in edge_set[key]:\n",
        "                    if vertex not in set_2_vertices: set_2_vertices.append(vertex)\n",
        "\n",
        "        colors = []\n",
        "        for i in range(self.n):\n",
        "            TeX += \"\\t\\\\definecolor{n\"+str(i)+\"}{hsb}{\"+str(round(float(i/self.n), 3))+\", 1, 1}\\n\"\n",
        "            colors.append(\"n\"+str(i))\n",
        "\n",
        "        offset = float((len(set_2_vertices) - len([key for key in edges[0]]))/2)\n",
        "\n",
        "        for i,key in enumerate([key for key in edges[0]]):\n",
        "            if key in S_1:\n",
        "                TeX += \"\\t\\\\node[cell_node] at (\"+str((i+offset)/2.8)+\",0) (1_\"+str(key)+\"){ \\\\small\"+str(key)+\" };\\n\"\n",
        "            else:\n",
        "                TeX += \"\\t\\\\node[non_cell_node] at (\"+str((i+offset)/2.8)+\",0) (1_\"+str(key)+\"){ \\\\small\"+str(key)+\" };\\n\"\n",
        "        for vertex in set_2_vertices:\n",
        "            if vertex in S_2:\n",
        "                TeX += \"\\t\\\\node[cell_node] at (\"+str(vertex/2.8)+\",10) (2_\"+str(vertex)+\"){ \\\\small\"+str(vertex)+\" };\\n\"\n",
        "            else:\n",
        "                TeX += \"\\t\\\\node[non_cell_node] at (\"+str(vertex/2.8)+\",10) (2_\"+str(vertex)+\"){ \\\\small\"+str(vertex)+\" };\\n\"\n",
        "\n",
        "        for i,edge_set in enumerate(edges):\n",
        "            for key in edge_set:\n",
        "                for vertex in edge_set[key]:\n",
        "                    TeX += \"\\t\\\\draw[\"+colors[i]+\"] (1_\"+str(key)+\")--(2_\"+str(vertex)+\");\\n\"\n",
        "\n",
        "        TeX += \"\\t\\\\end{tikzpicture}\\n\\\\end{landscape}\"\n",
        "\n",
        "        return TeX\n",
        "\n",
        "\n",
        "    def epsilon(self,k,K):\n",
        "        num = 0\n",
        "        for l in K:\n",
        "            if l <= k:\n",
        "                num += 1\n",
        "        return num\n",
        "\n",
        "    def check_comp(self,S_1,S_2,delta):\n",
        "            IorJ = (S_1,'I') if len(delta['minor']) == len(S_1) else (S_2,'J')\n",
        "            if delta['minor'] == IorJ[0]:\n",
        "                delta['color'] = 'green'\n",
        "                delta['one'] = True\n",
        "                delta['nonzero'] = True\n",
        "            for i in range(len(delta['minor'])):\n",
        "                if delta['minor'][i]>IorJ[0][i]:\n",
        "                    delta['color'] = 'red'\n",
        "                    delta['zero'] = True\n",
        "\n",
        "\n",
        "    def get_subsets(self,offset = 1):\n",
        "        subsets = []\n",
        "        for v_space in [(self.dim_I-offset,self.B_i), (self.dim_J+offset,self.B_j)]:\n",
        "            subsets.append([list(x) for x in list(itertools.combinations(v_space[1], v_space[0]))])\n",
        "        return subsets\n",
        "\n",
        "\n",
        "\n",
        "    def classic_E(self,v,I,J, S_1, S_2):\n",
        "        relation = Relation(v, I, J)\n",
        "        IorJ = 'i' if len(I) == self.dim_I-1 else 'j'\n",
        "        possible = [x for x in J if x not in I]\n",
        "        for i in possible:\n",
        "            pos = '+'\n",
        "            parity = \"-\" if (self.epsilon(i,I)+self.epsilon(i,J))%2 == 1 else pos\n",
        "\n",
        "            if sorted(I+[i]) not in self.minor_tracking[IorJ]:\n",
        "                t1 = Minor(sorted(I+[i]),'i')\n",
        "                self.minors[IorJ].append(t1)\n",
        "                self.minor_tracking[IorJ].append(sorted(I+[i]))\n",
        "            else:\n",
        "                t1 = self.minors[IorJ][self.minor_tracking[IorJ].index(sorted(I+[i]))]\n",
        "\n",
        "            if sorted([elem for elem in J if elem != i]) not in self.minor_tracking[IorJ]:\n",
        "                t2 = Minor(sorted([elem for elem in J if elem != i]),IorJ)\n",
        "                self.minors[IorJ].append(t2)\n",
        "                self.minor_tracking[IorJ].append(sorted([elem for elem in J if elem != i]))\n",
        "            else:\n",
        "                t2 = self.minors[IorJ][self.minor_tracking[IorJ].index(sorted([elem for elem in J if elem != i]))]\n",
        "\n",
        "            if (t1.minor, t2.minor) not in self.term_tracking:\n",
        "                term = Term(t1, t2, parity)\n",
        "                self.terms.append(term)\n",
        "                self.term_tracking.append((t1.minor, t2.minor))\n",
        "            else:\n",
        "                term = self.terms[self.term_tracking.index((t1.minor, t2.minor))]\n",
        "\n",
        "        return relation\n",
        "\n",
        "    def gen_comparison(self, S_1,S_2):\n",
        "        for i in range(len(S_1)):\n",
        "            if S_1[i]>S_2[i]:\n",
        "                return True\n",
        "        else:\n",
        "            return False\n",
        "\n",
        "\n",
        "    def E(self,v,I,J, S_1, S_2):\n",
        "        contradiction = False\n",
        "\n",
        "        for i in range(len(I)):\n",
        "            if I[i]>S_1[i] and I[i]>S_1[i+1]:\n",
        "                return (None, contradiction)\n",
        "\n",
        "\n",
        "        working_J = [j for j in J if j != max(J)]\n",
        "        for j in range(len(working_J)):\n",
        "            if working_J[j]>S_2[j]:\n",
        "                return (None, contradiction)\n",
        "\n",
        "\n",
        "        relation = {'v':v, 'I':I, 'J':J, 'left':[], 'right':[], 'category':None}\n",
        "        possible_j = list(J)\n",
        "        possible_i = [i for i in self.B_i if i not in I] #All i in range(dim_I) if i not in I\n",
        "        all_relevant_coords = [(i,j) for i,j in self.edges[v] if (i in possible_i) and (j in possible_j)]\n",
        "        for i,j in all_relevant_coords:\n",
        "            if self.gen_comparison(sorted(I+[i]), S_1):\n",
        "                continue\n",
        "            if self.gen_comparison(sorted([elem for elem in J if elem != j]), S_2):\n",
        "                continue\n",
        "\n",
        "            parity = -1 if (self.epsilon(i,I)+self.epsilon(j,J))%2 == 1 else 1\n",
        "\n",
        "            if sorted(I+[i]) not in self.minor_tracking['i']:\n",
        "                t1 = {'color':'black', 'minor':sorted(I+[i]),'parity':1, 'sub_id':'i', 'zero':False, 'one':False, 'nonzero':False}\n",
        "                self.minors['i'].append(t1)\n",
        "                self.minor_tracking['i'].append(sorted(I+[i]))\n",
        "            else:\n",
        "                t1 = self.minors['i'][self.minor_tracking['i'].index(sorted(I+[i]))]\n",
        "\n",
        "            if sorted([elem for elem in J if elem != j]) not in self.minors['j']:\n",
        "                t2 = {'color':'black', 'minor':sorted([elem for elem in J if elem != j]), 'parity':1, 'sub_id':'j', 'zero':False, 'one':False, 'nonzero':False}\n",
        "                self.minors['j'].append(t2)\n",
        "                self.minor_tracking['j'].append(sorted([elem for elem in J if elem != j]))\n",
        "            else:\n",
        "                t2 = self.minors['j'][self.minor_tracking['j'].index(sorted([elem for elem in J if elem != j]))]\n",
        "\n",
        "            if (t1['minor'], t2['minor'], parity) not in self.term_tracking:\n",
        "                term = {'I':t1, 'J':t2, 'parity':parity}\n",
        "                self.terms.append({'I':t1, 'J':t2, 'parity':parity})\n",
        "                self.term_tracking.append((t1['minor'], t2['minor'],parity))\n",
        "            else:\n",
        "                term = self.terms[self.term_tracking.index((t1['minor'], t2['minor'],parity))]\n",
        "\n",
        "            relation['right'].append(term)\n",
        "\n",
        "        if len(relation['right']) == 1 and relation['right'][0]['I']['minor'] == S_1 and relation['right'][0]['J']['minor'] == S_2:\n",
        "            contradiction = True\n",
        "\n",
        "\n",
        "        return (relation, contradiction)\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "    def classify_relation(self,relation, S_1, S_2):\n",
        "        full_relation = [term for term in relation['left']+relation['right'] if not self.gen_comparison(term['I']['minor'],S_1) and not self.gen_comparison(term['J']['minor'], S_2)]\n",
        "        if full_relation == []:\n",
        "            relation['category'] = 'Quadratic Relations'\n",
        "            return\n",
        "\n",
        "#         for term in full_relation:\n",
        "#             if term['I']['minor'] == S_1 and term['J']['minor'] == S_2:\n",
        "#                 relation['category'] = 'Contradiction'\n",
        "#                 return\n",
        "        colors = [term['I']['color'] for term in full_relation] + [term['J']['color'] for term in full_relation]\n",
        "\n",
        "        green_count = colors.count('green')\n",
        "        if green_count >= 2:\n",
        "            relation['category'] = 'Linear Dependancies'\n",
        "        elif green_count == 1:\n",
        "            relation['category'] = 'Quadratic Reductions'\n",
        "        else:\n",
        "            relation['category'] = 'Quadratic Relations'\n",
        "\n",
        "\n",
        "    def get_relevant_relations(self, relation, minor, IorJ, cell):\n",
        "        #We want all relations that contain a particular minor\n",
        "        possible = []\n",
        "        relevant = []\n",
        "        dim = len(cell)\n",
        "        if IorJ == 'I':\n",
        "            for i in minor['minor']:\n",
        "                possible_I = [j for j in minor['minor'] if j!= i]\n",
        "                for v in range(self.n):\n",
        "                    for edge in self.edges[v]:\n",
        "                        if edge[0] == i:\n",
        "                            relevant.append((v,edge, possible_I))\n",
        "        else:\n",
        "            for j in [i for i in range(self.dim2+1) if i not in minor['minor']]:\n",
        "                possible_J = minor['minor']+[j]\n",
        "                for v in range(self.n):\n",
        "                    for edge in self.edges[v]:\n",
        "                        if edge[1] == j:\n",
        "                            relevant.append((v,edge, possible_J))\n",
        "\n",
        "        for poss in relevant:\n",
        "            lowest = [i for i in range(dim)]\n",
        "            working = list(lowest)\n",
        "            incomplete = True\n",
        "            while incomplete:\n",
        "                print(working)\n",
        "                i = dim-1\n",
        "                if poss[1][1] in working:\n",
        "                    possible.append((poss[0],poss[2], list(working)))\n",
        "                while True:\n",
        "                    if working[i] != cell[i]:\n",
        "                        working[i]+=1\n",
        "                        break;\n",
        "                    else:\n",
        "                        working[i] = lowest[i]\n",
        "                        if i == 0:\n",
        "                            incomplete = False\n",
        "                            break;\n",
        "                        else:\n",
        "                            i -= 1\n",
        "        return possible\n",
        ""
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "RkOO1RqKTWnK"
      },
      "outputs": [],
      "source": [
        "\n",
        "\n",
        "def generate_schubert_cell_data(pl, S_1,S_2, dim1, dim2, dims, n):\n",
        "    print(\"HERE\")\n",
        "    marked_minors = []\n",
        "    marked_minor_tracking = []\n",
        "    minor_equalities = []\n",
        "    minor_equality_tracking_index = 0\n",
        "    used_minor_tracking = []\n",
        "    zeros = []\n",
        "    remaining_minors = []\n",
        "    reductions = []\n",
        "    reduction_tracking = []\n",
        "    all_minors = []\n",
        "    all_minor_tracking = []\n",
        "    all_relations_in_cell = []\n",
        "    relations = {'Quadratic Reductions':[], 'Linear Dependancies':[], 'Quadratic Relations':[],'Contradiction':[]}\n",
        "\n",
        "    all_relations = []\n",
        "    all_minors = []\n",
        "    cont = False\n",
        "    counter = 0\n",
        "\n",
        "#     for i in range(2**dim1):\n",
        "#         if cont: break\n",
        "#         binary_I = [int(j) for j in bin(i)[2:].zfill(dim1)]\n",
        "#         if sum(binary_I) == dims[0]-1:\n",
        "#             for j in range(2**dim2):\n",
        "#                 counter += 1\n",
        "#                 if cont: break\n",
        "#                 binary_J = [int(i) for i in bin(j)[2:].zfill(dim2)]\n",
        "#                 if sum(binary_J) == dims[1]+1:\n",
        "#                     I = [i for i in range(dim1) if binary_I[i] == 1]\n",
        "#                     J = [j for j in range(dim2) if binary_J[j] == 1]\n",
        "#                     for v in range(n):\n",
        "#                         if cont: break\n",
        "#                         relation,cont = pl.E(v,I, J, S_1, S_2)\n",
        "#                         if relation is not None:\n",
        "#                             all_relations.append(relation)\n",
        "\n",
        "\n",
        "#THE GOOD CODE:\n",
        "    for j in [elem for elem in range(dim2) if elem not in S_2]:\n",
        "            for i in S_1:\n",
        "                I = [x for x in S_1 if x!= i]\n",
        "                J = [x for x in S_2]+[j]\n",
        "                for v in range(n):\n",
        "                    if cont: break\n",
        "                    relation,cont = pl.E(v,I, J, S_1, S_2)\n",
        "                    if relation is not None:\n",
        "                        all_relations.append(relation)\n",
        "\n",
        "    print(\"relations generated\")\n",
        "\n",
        "    def reset_minor(minor):\n",
        "        minor['color'] = 'black'\n",
        "        minor['zero'] = False\n",
        "\n",
        "    def reset_relation(relation):\n",
        "        relation['right'] = relation['left'] + relation['right']\n",
        "        relation['left'] = []\n",
        "        for term in relation['right']:\n",
        "            reset_minor(term['I'])\n",
        "            reset_minor(term['J'])\n",
        "\n",
        "    for relation in all_relations:\n",
        "        copy = dict(relation)\n",
        "        reset_relation(copy)\n",
        "        for term in copy['right']:\n",
        "            pl.check_comp(S_1,S_2,term['I'])\n",
        "            pl.check_comp(S_1,S_2,term['J'])\n",
        "        pl.classify_relation(copy, S_1, S_2)\n",
        "        all_relations_in_cell.append(copy)\n",
        "        relations['Quadratic Reductions'].append(copy)\n",
        "\n",
        "    for indicator in [('i','I'),('j','J')]:\n",
        "        for minor in pl.minors:\n",
        "            if pl.minors[indicator[0]].count(minor) > 1:\n",
        "                copies = [x for x in pl.minors if x == minor]\n",
        "                for term in pl.terms:\n",
        "                    if term[indicator[1]] in copies:\n",
        "                        term[indicator[1]] = copies[0]\n",
        "                for _ in range(len(copies)-1):\n",
        "                    pl.minors.remove(minor)\n",
        "\n",
        "    print(\"relations classified\")\n",
        "#     for relation in all_relations_in_cell:\n",
        "#         for term in relation.left+relation.right:\n",
        "#             if term.I.minor not in all_minor_tracking:\n",
        "#                 all_minors.append(term.I)\n",
        "#                 all_minor_tracking.append(term.I.minor)\n",
        "#             else:\n",
        "#                 term.I = all_minors[all_minor_tracking.index(term.I.minor)]\n",
        "\n",
        "#             if term.J.minor not in all_minor_tracking:\n",
        "#                 all_minors.append(term.J)\n",
        "#                 all_minor_tracking.append(term.J.minor)\n",
        "#             else:\n",
        "#                 term.J = all_minors[all_minor_tracking.index(term.J.minor)]\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "    change = 1\n",
        "    relations = {'Quadratic Reductions':[], 'Linear Dependancies':[], 'Quadratic Relations':[],'Contradiction':[]}\n",
        "    while change > 0:\n",
        "        change = 0\n",
        "        deletion_indicies = []\n",
        "        new_minor_equalities = []\n",
        "        used_minors = [x[0] for x in used_minor_tracking]\n",
        "        used_minor_index = [x[1] for x in used_minor_tracking]\n",
        "        for rel_index,relation in enumerate(all_relations_in_cell):\n",
        "            if len(relation['right'])==2:\n",
        "#                 term_1 = relation['right'][0]\n",
        "#                 term_2 = relation['right'][1]\n",
        "#                 if term_1['parity'] == term_2['parity']:\n",
        "#                     parity = -1\n",
        "#                 else:\n",
        "#                     parity = 1\n",
        "#                 if (term_1['J']['one'] or term_1['I']['one']):\n",
        "#                     if(term_2['J']['one'] or term_2['I']['one']):\n",
        "#                         non_1_t1 = term_1['J'] if term_1['I']['one'] else term_1['I']\n",
        "#                         non_1_t2 = term_2['J'] if term_2['I']['one'] else term_2['I']\n",
        "#                         seen_minors = [1 if term in used_minors else 0 for term in [non_1_t1, non_1_t2]]\n",
        "\n",
        "#                         if sum(seen_minors)==1:\n",
        "#                             if non_1_t1 in used_minors:\n",
        "#                                 correct_index = used_minor_index[used_minors.index(non_1_t1)]\n",
        "#                                 equal_minors = [x[0] for x in minor_equalities[correct_index]]\n",
        "#                                 equal_minors_parity = [x[1] for x in minor_equalities[correct_index]]\n",
        "#                                 parity_adjustment = equal_minors_parity[equal_minors.index(non_1_t1)]#Gurantees we have the right parity for each term\n",
        "#                                 minor_equalities[correct_index].append((non_1_t1,parity_adjustment*parity))\n",
        "#                                 used_minors.append((non_1_t2,correct_index))\n",
        "#                             else:\n",
        "#                                 correct_index = used_minor_index[used_minors.index(non_1_t2)]\n",
        "#                                 equal_minors = [x[0] for x in minor_equalities[correct_index]]\n",
        "#                                 equal_minors_parity = [x[1] for x in minor_equalities[correct_index]]\n",
        "#                                 parity_adjustment = equak_minors_parity[equal_minors.index(non_1_t2)]#Gurantees we have the right parity for each term\n",
        "#                                 minor_equalities[correct_index].append((non_1_t1,parity_adjustment*parity))\n",
        "#                                 used_minors.append((non_1_t1,correct_index))\n",
        "#                         elif sum(seen_minors)==0:\n",
        "#                             new_minor_equalities.append((non_1_t1,non_1_t2,parity))\n",
        "#                         else:\n",
        "#                             pass\n",
        "#                             #check for parity contradiction\n",
        "\n",
        "\n",
        "\n",
        "                for term_i, term in enumerate(relation['right']):\n",
        "                    if term['J']['one'] and term['I']['one']:\n",
        "                        if relation['right'][term_i-1]['J']['one'] and (not relation['right'][term_i-1]['I']['one']):\n",
        "                            relation['right'][term_i-1]['I']['one'] = True\n",
        "                            relation['right'][term_i-1]['I']['nonzero'] = True\n",
        "                            if term['parity'] !=  relation['right'][term_i-1]['parity']:\n",
        "                                if term['J']['color'] == 'purple':\n",
        "                                    relation['right'][term_i-1]['I']['color'] = 'purple'\n",
        "                                else:\n",
        "                                    relation['right'][term_i-1]['I']['color'] = 'orange'\n",
        "                            else:\n",
        "                                relation['right'][term_i-1]['I']['color'] = 'purple'\n",
        "                            deletion_indicies.append(rel_index)\n",
        "                        elif relation['right'][term_i-1]['I']['one'] and (not relation['right'][term_i-1]['J']['one']):\n",
        "                            relation['right'][term_i-1]['J']['one'] = True\n",
        "                            relation['right'][term_i-1]['I']['nonzero'] = True\n",
        "                            if term['parity'] !=  relation['right'][term_i-1]['parity']:\n",
        "                                if term['J']['color'] == 'purple':\n",
        "                                    relation['right'][term_i-1]['J']['color'] = 'purple'\n",
        "                                else:\n",
        "                                    relation['right'][term_i-1]['J']['color'] = 'orange'\n",
        "                            else:\n",
        "                                relation['right'][term_i-1]['J']['color'] = 'purple'\n",
        "                            deletion_indicies.append(rel_index)\n",
        "                        else:\n",
        "                            relation['right'][term_i-1]['I']['nonzero'] = True\n",
        "                            relation['right'][term_i-1]['J']['nonzero'] = True\n",
        "                            if not relation['right'][term_i-1]['J']['one']:\n",
        "                                relation['right'][term_i-1]['J']['color'] = 'blue'\n",
        "                            if not relation['right'][term_i-1]['I']['one']:\n",
        "                                relation['right'][term_i-1]['I']['color'] = 'blue'\n",
        "                                if relation['right'][term_i-1]['I']['minor'] == [0,3,4,14]:\n",
        "                                    print(relation)\n",
        "\n",
        "\n",
        "            elif len(relation['right'])==1:\n",
        "\n",
        "                if (relation['right'][0]['I']['nonzero']) and (not relation['right'][0]['J']['nonzero']):\n",
        "                    relation['right'][0]['J']['zero'] = True\n",
        "                    relation['right'][0]['J']['color'] = 'red'\n",
        "                    deletion_indicies.append(rel_index)\n",
        "\n",
        "                if (relation['right'][0]['J']['nonzero']) and (not relation['right'][0]['I']['nonzero']):\n",
        "                    relation['right'][0]['I']['zero'] = True\n",
        "                    relation['right'][0]['I']['color'] = 'red'\n",
        "                    deletion_indicies.append(rel_index)\n",
        "\n",
        "#         for equality in new_minor_equalities:\n",
        "#             minor_1 = equality[0]\n",
        "#             minor_2 = equality[1]\n",
        "#             copy = dict(minor_2)\n",
        "#             used_minor_tracking.append((minor_1,minor_equality_tracking_index))\n",
        "#             used_minor_tracking.append((copy, minor_equality_tracking_index))\n",
        "#             minor_equalities.append([(minor_1,1),(copy,equality[2])])\n",
        "#             minor_equality_tracking_index+=1\n",
        "\n",
        "        # for del_index in deletion_indicies[::-1]:\n",
        "        #     del all_relations_in_cell[del_index]\n",
        "\n",
        "\n",
        "\n",
        "        # for rel in relations_to_add:\n",
        "        #     relevant_cell = S_1 if rel[2]==\"I\" else S_2\n",
        "        #     generators = pl.get_relevant_relations(rel[0],rel[1], rel[2], relevant_cell)\n",
        "        #     for poss in generators:\n",
        "        #         print(poss)\n",
        "        #         v = poss[0]\n",
        "        #         if rel[2] == 'I':\n",
        "        #             I = poss[1]\n",
        "        #             J = poss[2]\n",
        "        #         else:\n",
        "        #             I = poss[2]\n",
        "        #             J = poss[1]\n",
        "        #         if (I,J) not in used_cells:\n",
        "        #             relation,cont = pl.E(v,I, J, S_1, S_2)\n",
        "        #             used_cells.append((I,J))\n",
        "        #             copy = dict(relation)\n",
        "        #             for term in copy['right']:\n",
        "        #                 pl.check_comp(S_1,S_2,term['I'])\n",
        "        #                 pl.check_comp(S_1,S_2,term['J'])\n",
        "        #             pl.classify_relation(copy, S_1, S_2)\n",
        "        #             all_relations_in_cell.append(copy)\n",
        "        #             print(I,J)\n",
        "        #             relations[copy['category']].append(copy)\n",
        "        #    adjust with new zeros\n",
        "\n",
        "        # for rel_index,relation in enumerate(all_relations_in_cell):\n",
        "        #     for term_index,term in enumerate(relation['right']):\n",
        "        #         if term['I']['zero'] or term['J']['zero']:\n",
        "        #             del relation['right'][term_index]\n",
        "        #             change += 1\n",
        "\n",
        "            #re-classify\n",
        "\n",
        "    print(\"relations solved\")\n",
        "\n",
        "\n",
        "    for rel_index,relation in enumerate(all_relations_in_cell):\n",
        "        pl.classify_relation(relation, S_1, S_2)\n",
        "        relations[relation['category']].append(relation)\n",
        "\n",
        "\n",
        "#     for key in relations:\n",
        "#         for relation in relations[key]:\n",
        "#             i2 = relations[key].index(relation)\n",
        "#             left = []\n",
        "#             zero_i = []\n",
        "#             for i,term in enumerate(relation['right']):\n",
        "#                 i_status = term['I']['color']\n",
        "#                 j_status = term['J']['color']\n",
        "#                 if i_status == 'green' or j_status == 'green':\n",
        "#                     left.append(i)\n",
        "\n",
        "#             relation['left'] = [relation['right'][i] for i in left]\n",
        "#             for term in relation['left']:\n",
        "#                 if term['parity'] == 1:\n",
        "#                     term['parity'] = -1\n",
        "#                 else:\n",
        "#                     term['parity'] = 1\n",
        "\n",
        "#             for i,term in enumerate(sorted(left)):\n",
        "#                 del relation['right'][term-i]\n",
        "\n",
        "\n",
        "    # deletion_indices = []\n",
        "    # for i,relation in enumerate(relations['Contradiction']):\n",
        "    #     if len([x for x in relation['left'] if (not x['I']['zero']) and (not x['J']['zero'])])>1:\n",
        "    #         deletion_indices.append(i)\n",
        "\n",
        "    # for index, deletion in enumerate(deletion_indices):\n",
        "    #     relations['Quadratic Reductions'].append(relations['Contradiction'][deletion-index])\n",
        "    #     del relations['Contradiction'][deletion-index]\n",
        "\n",
        "#     old = [0]\n",
        "#     while old != marked_minors:\n",
        "#         old = list(marked_minors)\n",
        "\n",
        "\n",
        "#         for i,relation in enumerate(relations['Quadratic Reductions']):\n",
        "#             if [term for term in relation['right'] if (not term['I']['zero']) and (not term['J']['zero'])] == [] and len(relation['left']) == 1:\n",
        "#                 if (relation['left'][0]['I']['color'] == 'green') and relation['left'][0]['J']['minor'] != S_2:\n",
        "#                     if relation['left'][0]['J']['color'] != 'green':\n",
        "#                         relation['left'][0]['J']['color'] = 'orange'\n",
        "#                         relation['left'][0]['J']['zero'] = True\n",
        "#                     if relation['left'][0]['J'] not in marked_minors:\n",
        "#                         marked_minors.append(relation['left'][0]['J'])\n",
        "#                         marked_minor_tracking.append(relation['left'][0]['J']['minor'])\n",
        "#                 elif (relation['left'][0]['J']['color'] == 'green') and relation['left'][0]['I']['minor'] != S_1:\n",
        "#                     if relation['left'][0]['I']['color'] != 'green':\n",
        "#                         relation['left'][0]['I']['color'] = 'orange'\n",
        "#                         relation['left'][0]['I']['zero'] = True\n",
        "#                     if relation['left'][0]['I'] not in marked_minors:\n",
        "#                         marked_minors.append(relation['left'][0]['I'])\n",
        "#                         marked_minor_tracking.append(relation['left'][0]['I']['minor'])\n",
        "\n",
        "#         for i,relation in enumerate(relations['Linear Dependancies']):\n",
        "#             if [term for term in relation['right'] if term['I']['color'] != 'orange' and term['J']['color'] != 'orange'] == []:\n",
        "#                 for i in range(2):\n",
        "#                     if 'orange' in [relation['left'][i-1]['I']['color'], relation['left'][i-1]['J']['color']]:\n",
        "#                             if relation['left'][i]['I']['color'] == 'green' and relation['left'][i]['J']['minor'] != S_2:\n",
        "#                                 relation['left'][i]['J']['color'] = 'orange'\n",
        "#                                 relation['left'][i]['J']['zero'] = True\n",
        "#                                 if relation['left'][i]['J'] not in marked_minors:\n",
        "#                                     marked_minors.append(relation['left'][i]['J'])\n",
        "#                                     marked_minor_tracking.append(relation['left'][i]['J']['minor'])\n",
        "#                             elif relation['left'][i]['J']['color'] == 'green' and relation['left'][i]['I']['minor'] != S_1:\n",
        "#                                 relation['left'][i]['I']['color'] = 'orange'\n",
        "#                                 relation['left'][i]['I']['zero'] = True\n",
        "#                                 if relation['left'][i]['I'] not in marked_minors:\n",
        "#                                     marked_minors.append(relation['left'][i]['I'])\n",
        "#                                     marked_minor_tracking.append(relation['left'][i]['I']['minor'])\n",
        "\n",
        "\n",
        "#                     if relation['left'][i-1]['I']['one'] and relation['left'][i-1]['J']['one']:\n",
        "#                         if relation['left'][i]['I']['one']:\n",
        "#                             relation['left'][i]['J']['one'] = True\n",
        "#                             if relation['left'][i]['J'] not in marked_minors:\n",
        "#                                     marked_minors.append(relation['left'][i]['J'])\n",
        "#                                     marked_minor_tracking.append(relation['left'][i]['J']['minor'])\n",
        "#                         elif relation['left'][i]['J']['one']:\n",
        "#                             relation['left'][i]['I']['one'] = True\n",
        "#                             if relation['left'][i]['I'] not in marked_minors:\n",
        "#                                     marked_minors.append(relation['left'][i]['I'])\n",
        "#                                     marked_minor_tracking.append(relation['left'][i]['I']['minor'])\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "#     for index,subset in enumerate([(S_1,'i'),(S_2,'j')]):\n",
        "#         possible_minors = list(itertools.combinations([i for i in range([dim1,dim2][index])], len(subset[0])))\n",
        "#         for s_i in [list(x) for x in possible_minors]:\n",
        "#             for i in range(len(s_i)):\n",
        "#                 if s_i[i] > subset[0][i]:\n",
        "#                     red = {'color':'red', 'minor':sorted(s_i), 'sub_id':subset[1], 'zero':True, 'one':False}\n",
        "#                     marked_minor_tracking.append(s_i)\n",
        "#                     zeros.append(red)\n",
        "#                     break\n",
        "#             else:\n",
        "#                 if s_i == subset[0]:\n",
        "#                     green ={'color':'green', 'minor':sorted(s_i), 'sub_id':subset[1], 'zero':False, 'one':True}\n",
        "#                     remaining_minors.append(green)\n",
        "#                 elif s_i in marked_minor_tracking:\n",
        "\n",
        "#                     orange = {'color':'orange', 'minor':sorted(s_i), 'sub_id':subset[1], 'zero':True, 'one':False}\n",
        "#                     remaining_minors.append(orange)\n",
        "#                 else:\n",
        "#                     remaining_minors.append({'color':'black', 'minor':sorted(s_i), 'sub_id':subset[1], 'zero':False, 'one':False})\n",
        "\n",
        "\n",
        "\n",
        "#     remaining_minors = [x for i,x in enumerate(remaining_minors) if x['minor'] not in reduction_tracking]\n",
        "\n",
        "    def sort_terms(term):\n",
        "        return sum([(10**(len(term['J']['minor'])-i-1))*term['J']['minor'][i] for i in range(len(term['J']['minor']))])\n",
        "\n",
        "    for key in relations:\n",
        "        for relation in relations[key]:\n",
        "            if relation['left'] == [] and relation['right'] == []:\n",
        "                relations[key].remove(relation)\n",
        "            else:\n",
        "                relation['left'] = sorted(relation['left'], key = sort_terms)\n",
        "                relation['right'] = sorted(relation['right'], key = sort_terms)\n",
        "#                 for side in [relation['left'],relation['right']]:\n",
        "#                     for i,term in enumerate(side):\n",
        "#                         if term['parity'] != '-':\n",
        "#                             if i == 0:\n",
        "#                                 term['parity'] = ''\n",
        "#                             else:\n",
        "#                                 print(term)\n",
        "#                                 term['parity'] = '+'\n",
        "\n",
        "    def sort_relations(relation):\n",
        "        return relation['J'][-1]\n",
        "\n",
        "    new_relations = relations['Quadratic Reductions']+relations['Linear Dependancies']+relations['Quadratic Relations']\n",
        "    sorted_relations = sorted(new_relations, key = sort_relations)\n",
        "\n",
        "\n",
        "    def sort_minors(minor):\n",
        "        return (len(minor['minor']),sum([(10**(len(minor['minor'])-i-1))*minor['minor'][i] for i in range(len(minor['minor']))]))\n",
        "\n",
        "#     return {'Cell':(S_1,S_2),'Relations':relations, 'Remaining Minors':sorted(remaining_minors, key = sort_minors),\n",
        "#             'Zeros': sorted(zeros,key = sort_minors), 'Dimension':0, 'Contradiction': False}\n",
        "\n",
        "    return {'Cell':(S_1,S_2),'Relations':sorted_relations, 'Remaining Minors':[],\n",
        "            'Zeros': [], 'Minor Equalities': minor_equalities, 'Dimension':0, 'Contradiction': False}"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "KmZ9NNXTTWnL"
      },
      "outputs": [],
      "source": [
        "def generate_cell_TeX(cell):\n",
        "    TeX_data = \"\"\n",
        "    S_1 = cell['Cell'][0]\n",
        "    S_2 = cell['Cell'][1]\n",
        "    compatible_info = []\n",
        "    display = True\n",
        "#     if cell['Relations']['Contradiction'] == []:\n",
        "#         compatible_info.append(str(S_1)+\",\"+str(S_2))\n",
        "#         TeX_data += \"\\n\\\\hypertarget{\"+str(S_1)+\",\"+str(S_2)+\"}{}\"\n",
        "#         TeX_data += \"\\n\\\\begin{mdframed}\\n\\\\subsection[Test]{$S_1 = \"+str(S_1)+\", S_2 = \"+str(S_2)+\"$}${}$\\n\\\\end{mdframed}\\n\"\n",
        "#     else:\n",
        "#         display = False\n",
        "\n",
        "    TeX_data += \"\\\\subsection{$S_1 = \"+str(S_1)+\", S_2 = \"+str(S_2)+\"$}\\n\"\n",
        "\n",
        "    def relation_display(relation):\n",
        "        left = '0'if relation['left'] == [] else ' '.join([term_display(term) for term in relation['left']])\n",
        "        right = '0'if relation['right'] == [] else ' '.join([term_display(term) for term in relation['right']])\n",
        "        relation_tex = \"\\\\begin{align*}\"\n",
        "        relation_tex += str(relation['I'])+\"\\\\\\ \"+str(relation['J'])\n",
        "        relation_tex += \"\\\\end{align*}\\n\"\n",
        "        relation_tex += \"\\\\begin{align*}\"\n",
        "        if left == '':\n",
        "            relation_tex += '0'\n",
        "        else:\n",
        "            relation_tex += left\n",
        "        relation_tex += \"\\\\overset{v=\"+str(relation['v'])+\"}{=}\"\n",
        "        if right == '':\n",
        "            relation_tex += '0'\n",
        "        else:\n",
        "            relation_tex += right\n",
        "        return relation_tex + \"\\\\end{align*}\\n\"\n",
        "\n",
        "    def minor_display(minor):\n",
        "        parity = \"\" if minor['parity'] == 1 else \"(-\"\n",
        "        close = \"\" if minor['parity'] == 1 else \")\"\n",
        "        if minor['sub_id'] == 'i':\n",
        "            min_id = ([x for x in S_1 if x not in minor['minor']],[x for x in range(dim1) if x in minor['minor'] and x not in S_1])\n",
        "        else:\n",
        "            min_id =([x for x in S_2 if x not in minor['minor']],[x for x in range(dim2) if x in minor['minor'] and x not in S_2])\n",
        "\n",
        "        return \"\\\\textcolor{\"+minor['color']+\"}{\"+parity+\"{}_{\"+minor['sub_id']+\"}\\\\Delta_{\"+str(min_id)+\"}\"+close+\"}\"\n",
        "\n",
        "    def term_display(term):\n",
        "#         if term['I']['zero'] or term['J']['zero']:\n",
        "#             return ''\n",
        "        parity = \"+\" if term['parity'] == 1 else \"-\"\n",
        "        term_tex = \"\\\\:\"+parity\n",
        "        term_tex += minor_display(term['I'])+\"\\\\;\"+minor_display(term['J'])+\"\\\\\\ \"\n",
        "        return term_tex\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "    TeX_data += \"\\\\subsubsection{Coefficent Quiver}\"\n",
        "    TeX_data += pl.display_succesor_graph(S_1,S_2)\n",
        "\n",
        "#     TeX_data += TeX['Contradiction']\n",
        "\n",
        "    if display:\n",
        "#         TeX_data += \"\\\\subsubsection{Remaining Minors}\\n\"\n",
        "#         TeX_data += \"\\\\begin{align*}\\n&\"\n",
        "#         term_size = 0\n",
        "\n",
        "#         equation = ''\n",
        "#         for minor in cell['Remaining Minors']:\n",
        "\n",
        "#             equation += minor.display()\n",
        "#             equation += ', '\n",
        "#             term_size += 7+len(minor.minor)\n",
        "#             if (term_size+7+len(minor.minor))%104 < 8+len(minor.minor):\n",
        "#                 equation += \"\\\\\\\\&\"\n",
        "#                 term_size = 0\n",
        "#         TeX_data += \"\"+equation+\"\\\\\\\\&\\n\"\n",
        "#         TeX_data += \"\\\\end{align*}\\n\"\n",
        "        for relation in cell['Relations']:\n",
        "            if relation['left'] != [] or relation['right'] != []:\n",
        "                relation_tex = relation_display(relation)\n",
        "                if len(relation_tex) > 100:\n",
        "                    TeX_data += relation_tex\n",
        "\n",
        "        TeX_data += \"\\\\end{align*}\\n\"\n",
        "\n",
        "        TeX_data += \"\\\\subsubsection{Minor Reductions}\\n\"\n",
        "        term_size = 0\n",
        "\n",
        "        for equality_set in cell['Minor Equalities']:\n",
        "            TeX_data += \"\\\\begin{align*}\"\n",
        "            print(equality_set)\n",
        "            equation = ''\n",
        "            for minor_i,minor in enumerate(equality_set):\n",
        "                parity = \"-\"if minor[1] == -1 else \"\"\n",
        "                equation += parity\n",
        "                equation += minor_display(minor[0])\n",
        "                if minor_i != len(equality_set)-1:\n",
        "                    equation += '='\n",
        "            TeX_data += equation\n",
        "            TeX_data += \"\\\\end{align*}\\n\"\n",
        "\n",
        "#         if cell['Relations']['Contradiction'] == []:\n",
        "#             compatible_info.append(cell['Dimension'])\n",
        "#             compatible_pairs.append(compatible_info)\n",
        "\n",
        "    return TeX_data"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 21,
      "metadata": {
        "id": "8sXCZ4vzTWnL"
      },
      "outputs": [],
      "source": [
        "def u(t,n):\n",
        "    if t == 0:\n",
        "        return 0\n",
        "    elif t == 1:\n",
        "        return 1\n",
        "    else:\n",
        "        return ((n*u(t-1,n)) - u(t-2,n))\n",
        "\n",
        "def DABC(n,t,rep, S_1, S_2):\n",
        "\n",
        "    u_t = u(t,n)\n",
        "    u_tm1 = u(t-1,n)\n",
        "    u_tp1 = u(t+1,n)\n",
        "\n",
        "    #S_1b = i in S_1 with |Sigma_n(i)| > 1\n",
        "    Sigma = lambda r,i: rep[r][i][1]\n",
        "    Sigma_n = lambda i: [y for x,y in rep[n-1] if x==i]\n",
        "\n",
        "    S_1b = [i for i in S_1 if len(Sigma_n(i)) > 1]\n",
        "    print(S_1b)\n",
        "    #Sg_nb = \\bigcup Sg_n(i) for 1<i<u_{t-1}\n",
        "    Sg_nb = []\n",
        "    s_1max = max([i for i in S_1 if i<=u_tm1])\n",
        "    for i in range(s_1max):\n",
        "        Sg_nb += Sigma_n(i)\n",
        "\n",
        "    Sg_nb = sorted(Sg_nb)\n",
        "    print(Sg_nb)\n",
        "    #[u_{t+1}]' = v not in S_2 with v not on arrow n\n",
        "    u_tp1p = [v for v in range(u_tp1-(u_t-u_tm1)) if (v not in S_2)]\n",
        "    print(u_tp1p)\n",
        "    #S_2circ = s in S_2 s = s_r(i_circ) for i_circ not in S_1 (accomidatoins or extra nss)\n",
        "    S_2circ = [s  for r in range(n-1) for i,s in rep[r] if (i not in S_1) and (s in S_2)]\n",
        "    print(S_2circ)\n",
        "    #k(v) in S_1 such that s_r(k(v)) = v\n",
        "\n",
        "    D = []\n",
        "    for i in S_1b:\n",
        "        D.append([])\n",
        "        for s in Sg_nb:\n",
        "            if s in Sigma_n(i):\n",
        "                D_is = 1\n",
        "            else:\n",
        "                for h in range(u_t):\n",
        "                    if h not in S_1 and s in Sigma_n(h) and (h<i):\n",
        "                        D_is = {'id':\"-\",\"sign\":1, \"minor\":(i,h)}\n",
        "                else:\n",
        "                    D_is = 0\n",
        "            D[-1].append(D_is)\n",
        "\n",
        "    A = []\n",
        "\n",
        "    def k(v,compliment = True):\n",
        "        if compliment:\n",
        "            search_set = S_1\n",
        "        else:\n",
        "            search_set = [x for x in range(u_t) if x not in S_1]\n",
        "\n",
        "        for r in range(n-1):\n",
        "            for x in search_set:\n",
        "                if Sigma(r,x) == v:\n",
        "                    return (r,x)\n",
        "\n",
        "    for s in Sg_nb:\n",
        "        A.append([])\n",
        "        for v in u_tp1p:\n",
        "            try:\n",
        "                r,k_v = k(v)\n",
        "                s_ri= [{'id':\"-\",\"sign\":\"\", \"minor\":(i,k_v)} for i in S_1 if (rep[r][i] == s) and (k_v < i)]\n",
        "            except TypeError:\n",
        "                s_ri = []\n",
        "\n",
        "            if s==v:\n",
        "                A_sv = -1\n",
        "            elif len(s_ri) > 0:\n",
        "                A_sv = s_ri[0]\n",
        "            else:\n",
        "                A_sv = 0\n",
        "            A[-1].append(A_sv)\n",
        "\n",
        "    B = []\n",
        "    for s in Sg_nb:\n",
        "        B.append([])\n",
        "        for sp in S_2circ:\n",
        "            r1=0\n",
        "            r2=0\n",
        "            try:\n",
        "                r1,i_c = k(sp,False)\n",
        "                r2,i_b = k(s)\n",
        "            except TypeError:\n",
        "                r_1 = 0\n",
        "                i_c = 0\n",
        "                i_b = 0\n",
        "                r_2 = 1\n",
        "\n",
        "            if s == sp:\n",
        "                B_ssp = 1\n",
        "            if r1 == r2 and i_c < i_b:\n",
        "               B_ssp= {'id':\"-\",\"sign\":\"-\", \"minor\":(i_b,i_c)}\n",
        "            else:\n",
        "                B_ssp = 0\n",
        "            B[-1].append(B_ssp)\n",
        "\n",
        "    C = []\n",
        "    for sp in S_2circ:\n",
        "        C.append([])\n",
        "        for v in u_tp1p:\n",
        "            if v < sp:\n",
        "                C[-1].append({'id':\"+\",\"sign\":\"\", \"minor\":(v,sp)})\n",
        "            else:\n",
        "                C[-1].append(0)\n",
        "\n",
        "    return D,A,B,C\n",
        ""
      ]
    },
    {
      "cell_type": "code",
      "source": [
        "def tex_DABC(D,A,B,C):\n",
        "    max_cols = max([len(D),len(D[0]),len(A[0]),len(B[0])])\n",
        "    tex = \"\\setcounter{MaxMatrixCols}{\"+str(max_cols)+\"}\\n\"\n",
        "    tex += \"$$D = \\\\begin{bmatrix}\"\n",
        "#D\n",
        "    for row in D:\n",
        "        for entry in row:\n",
        "            if type(entry) == dict:\n",
        "                tex+= entry[\"sign\"]+\"\\\\tilde\\\\Delta^{\"+entry[\"id\"]+\"}_{\"+str(entry[\"minor\"])+\"}\"\n",
        "            else:\n",
        "                tex+= str(entry)\n",
        "            tex+=\" & \"\n",
        "        tex = tex[:-3]\n",
        "        tex += \"\\\\\\ \\n\"\n",
        "    tex = tex[:-4]\n",
        "    tex+= \"\\\\end{bmatrix}$$\\n\\n\"\n",
        "    tex+=\"$$A = \\\\begin{bmatrix}\"\n",
        "# A\n",
        "    for row in A:\n",
        "        for entry in row:\n",
        "            if type(entry) == dict:\n",
        "                tex+= entry[\"sign\"]+\"\\\\tilde\\\\Delta^{\"+entry[\"id\"]+\"}_{\"+str(entry[\"minor\"])+\"}\"\n",
        "            else:\n",
        "                tex+= str(entry)\n",
        "            tex+=\" & \"\n",
        "        tex = tex[:-3]\n",
        "        tex += \"\\\\\\ \\n\"\n",
        "    tex = tex[:-4]\n",
        "    tex+=\"\\\\end{bmatrix}$$\\n\\n\"\n",
        "\n",
        "    tex+= \"$$B= \\\\begin{bmatrix}\"\n",
        "#B\n",
        "    for row in B:\n",
        "        for entry in row:\n",
        "            if type(entry) == dict:\n",
        "                tex+= entry[\"sign\"]+\"\\\\tilde\\\\Delta^{\"+entry[\"id\"]+\"}_{\"+str(entry[\"minor\"])+\"}\"\n",
        "            else:\n",
        "                tex+= str(entry)\n",
        "            tex+=\" & \"\n",
        "        tex = tex[:-3]\n",
        "        tex += \"\\\\\\ \\n\"\n",
        "    tex = tex[:-4]\n",
        "    tex+= \"\\\\end{bmatrix}$$\\n\\n\"\n",
        "    tex+= \"$$C = \\\\begin{bmatrix}\"\n",
        "# C\n",
        "    for row in C:\n",
        "        for entry in row:\n",
        "            if type(entry) == dict:\n",
        "                tex+= entry[\"sign\"]+\"\\\\tilde\\\\Delta^{\"+entry[\"id\"]+\"}_{\"+str(entry[\"minor\"])+\"}\"\n",
        "            else:\n",
        "                tex+= str(entry)\n",
        "            tex+=\" & \"\n",
        "        tex = tex[:-3]\n",
        "        tex += \"\\\\\\ \\n\"\n",
        "    tex = tex[:-4]\n",
        "    tex+=\"\\\\end{bmatrix}$$\\n\\n\"\n",
        "\n",
        "    return tex"
      ],
      "metadata": {
        "id": "5f-jDWshWFzX"
      },
      "execution_count": 22,
      "outputs": []
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "A6IV-8v5TWnL",
        "outputId": "5b2271e9-a71f-4872-eebc-82be6cb6ad54"
      },
      "outputs": [
        {
          "name": "stdout",
          "output_type": "stream",
          "text": [
            "HERE\n",
            "relations generated\n",
            "relations classified\n",
            "relations solved\n",
            "complete: 0.04544568061828613\n"
          ]
        },
        {
          "ename": "",
          "evalue": "",
          "output_type": "error",
          "traceback": [
            "\u001b[1;31mThe Kernel crashed while executing code in the current cell or a previous cell. \n",
            "\u001b[1;31mPlease review the code in the cell(s) to identify a possible cause of the failure. \n",
            "\u001b[1;31mClick <a href='https://aka.ms/vscodeJupyterKernelCrash'>here</a> for more info. \n",
            "\u001b[1;31mView Jupyter <a href='command:jupyter.viewOutput'>log</a> for further details."
          ]
        }
      ],
      "source": [
        "import itertools\n",
        "\n",
        "import time\n",
        "n=4\n",
        "t=4\n",
        "dim1 = 56\n",
        "dim2 = 209\n",
        "dim_I = 11\n",
        "dim_J = 44\n",
        "start = time.time()\n",
        "# representation = {0:[(0, 0), (1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6), (7, 7), (8, 8), (9, 9), (10, 10), (11, 11), (12, 12), (13, 13), (14, 14), (15, 15), (16, 16), (17, 17), (18, 18), (19, 19), (20, 20), (21, 21), (22, 22), (23, 23)]\n",
        "# ,1:[(0, 24), (1, 25), (2, 26), (3, 27), (4, 28), (5, 29), (6, 30), (7, 31), (8, 32), (9, 33), (10, 34), (11, 35), (12, 36), (13, 37), (14, 38), (15, 39), (16, 40), (17, 41), (18, 42), (19, 43), (20, 44), (21, 45), (22, 46), (23, 47)]\n",
        "# ,2:[(0, 48), (1, 49), (2, 50), (3, 51), (4, 52), (5, 53), (6, 54), (7, 55), (8, 56), (9, 57), (10, 58), (11, 59), (12, 60), (13, 61), (14, 62), (15, 63), (16, 64), (17, 65), (18, 66), (19, 67), (20, 68), (21, 69), (22, 70), (23, 71)]\n",
        "# ,3:[(0, 72), (1, 73), (2, 74), (3, 75), (4, 76), (5, 77), (6, 78), (7, 79), (8, 80), (9, 81), (10, 82), (11, 83), (12, 84), (13, 85), (14, 86), (15, 87), (16, 88), (17, 89), (18, 90), (19, 91), (20, 92), (21, 93), (22, 94), (23, 95)]\n",
        "# ,4:[(0, 5), (1, 6), (2, 7), (3, 8), (4, 9), (0, 34), (1, 35), (2, 36), (3, 37), (4, 38), (0, 63), (1, 64), (2, 65), (3, 66), (4, 67), (0, 73), (0, 79), (0, 85), (0, 91), (1, 92), (2, 93), (3, 94), (4, 95), (5, 96), (6, 97), (7, 98), (8, 99), (9, 100), (10, 101), (11, 102), (12, 103), (13, 104), (14, 105), (15, 106), (16, 107), (17, 108), (18, 109), (19, 110), (20, 111), (21, 112), (22, 113), (23, 114)]}\n",
        "\n",
        "# representation = {0: [(0, 0), (1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6), (7, 7), (8, 8), (9, 9), (10, 10), (11, 11), (12, 12), (13, 13), (14, 14)]\n",
        "# ,1: [(0, 15), (1, 16), (2, 17), (3, 18), (4, 19), (5, 20), (6, 21), (7, 22), (8, 23), (9, 24), (10, 25), (11, 26), (12, 27), (13, 28), (14, 29)]\n",
        "# ,2: [(0, 30), (1, 31), (2, 32), (3, 33), (4, 34), (5, 35), (6, 36), (7, 37), (8, 38), (9, 39), (10, 40), (11, 41), (12, 42), (13, 43), (14, 44)]\n",
        "# ,3: [(0, 4), (1, 5), (2, 6), (3, 7), (0, 23), (1, 24), (2, 25), (3, 26), (0, 31), (0, 36), (0, 41), (1, 42), (2, 43), (3, 44), (4, 45), (5, 46), (6, 47), (7, 48), (8, 49), (9, 50), (10, 51), (11, 52), (12, 53), (13, 54), (14, 55)]}\n",
        "\n",
        "representation = {0:[(0, 0), (1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6), (7, 7), (8, 8), (9, 9), (10, 10), (11, 11), (12, 12), (13, 13), (14, 14), (15, 15), (16, 16), (17, 17), (18, 18), (19, 19), (20, 20), (21, 21), (22, 22), (23, 23), (24, 24), (25, 25), (26, 26), (27, 27), (28, 28), (29, 29), (30, 30), (31, 31), (32, 32), (33, 33), (34, 34), (35, 35), (36, 36), (37, 37), (38, 38), (39, 39), (40, 40), (41, 41), (42, 42), (43, 43), (44, 44), (45, 45), (46, 46), (47, 47), (48, 48), (49, 49), (50, 50), (51, 51), (52, 52), (53, 53), (54, 54), (55, 55)]\n",
        ",\n",
        "1:[(0, 56), (1, 57), (2, 58), (3, 59), (4, 60), (5, 61), (6, 62), (7, 63), (8, 64), (9, 65), (10, 66), (11, 67), (12, 68), (13, 69), (14, 70), (15, 71), (16, 72), (17, 73), (18, 74), (19, 75), (20, 76), (21, 77), (22, 78), (23, 79), (24, 80), (25, 81), (26, 82), (27, 83), (28, 84), (29, 85), (30, 86), (31, 87), (32, 88), (33, 89), (34, 90), (35, 91), (36, 92), (37, 93), (38, 94), (39, 95), (40, 96), (41, 97), (42, 98), (43, 99), (44, 100), (45, 101), (46, 102), (47, 103), (48, 104), (49, 105), (50, 106), (51, 107), (52, 108), (53, 109), (54, 110), (55, 111)]\n",
        ",\n",
        "2:[(0, 112), (1, 113), (2, 114), (3, 115), (4, 116), (5, 117), (6, 118), (7, 119), (8, 120), (9, 121), (10, 122), (11, 123), (12, 124), (13, 125), (14, 126), (15, 127), (16, 128), (17, 129), (18, 130), (19, 131), (20, 132), (21, 133), (22, 134), (23, 135), (24, 136), (25, 137), (26, 138), (27, 139), (28, 140), (29, 141), (30, 142), (31, 143), (32, 144), (33, 145), (34, 146), (35, 147), (36, 148), (37, 149), (38, 150), (39, 151), (40, 152), (41, 153), (42, 154), (43, 155), (44, 156), (45, 157), (46, 158), (47, 159), (48, 160), (49, 161), (50, 162), (51, 163), (52, 164), (53, 165), (54, 166), (55, 167)]\n",
        ",\n",
        "3:[(0, 15), (1, 16), (2, 17), (3, 18), (4, 19), (5, 20), (6, 21), (7, 22), (8, 23), (9, 24), (10, 25), (11, 26), (12, 27), (13, 28), (14, 29), (0, 86), (1, 87), (2, 88), (3, 89), (4, 90), (5, 91), (6, 92), (7, 93), (8, 94), (9, 95), (10, 96), (11, 97), (12, 98), (13, 99), (14, 100), (0, 116), (1, 117), (2, 118), (3, 119), (0, 135), (1, 136), (2, 137), (3, 138), (0, 143), (0, 148), (0, 153), (1, 154), (2, 155), (3, 156), (4, 157), (5, 158), (6, 159), (7, 160), (8, 161), (9, 162), (10, 163), (11, 164), (12, 165), (13, 166), (14, 167), (15, 168), (16, 169), (17, 170), (18, 171), (19, 172), (20, 173), (21, 174), (22, 175), (23, 176), (24, 177), (25, 178), (26, 179), (27, 180), (28, 181), (29, 182), (30, 183), (31, 184), (32, 185), (33, 186), (34, 187), (35, 188), (36, 189), (37, 190), (38, 191), (39, 192), (40, 193), (41, 194), (42, 195), (43, 196), (44, 197), (45, 198), (46, 199), (47, 200), (48, 201), (49, 202), (50, 203), (51, 204), (52, 205), (53, 206), (54, 207), (55, 208)]\n",
        "}\n",
        "\n",
        "# representation = {0: [(0, 0), (1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6), (7, 7), (8, 8), (9, 9), (10, 10), (11, 11), (12, 12), (13, 13), (14, 14), (15, 15), (16, 16), (17, 17), (18, 18), (19, 19), (20, 20), (21, 21), (22, 22), (23, 23), (24, 24), (25, 25), (26, 26), (27, 27), (28, 28), (29, 29), (30, 30), (31, 31), (32, 32), (33, 33), (34, 34), (35, 35), (36, 36), (37, 37), (38, 38), (39, 39), (40, 40), (41, 41), (42, 42), (43, 43), (44, 44), (45, 45), (46, 46), (47, 47), (48, 48), (49, 49), (50, 50), (51, 51), (52, 52), (53, 53), (54, 54)]\n",
        "# ,1: [(0, 55), (1, 56), (2, 57), (3, 58), (4, 59), (5, 60), (6, 61), (7, 62), (8, 63), (9, 64), (10, 65), (11, 66), (12, 67), (13, 68), (14, 69), (15, 70), (16, 71), (17, 72), (18, 73), (19, 74), (20, 75), (21, 76), (22, 77), (23, 78), (24, 79), (25, 80), (26, 81), (27, 82), (28, 83), (29, 84), (30, 85), (31, 86), (32, 87), (33, 88), (34, 89), (35, 90), (36, 91), (37, 92), (38, 93), (39, 94), (40, 95), (41, 96), (42, 97), (43, 98), (44, 99), (45, 100), (46, 101), (47, 102), (48, 103), (49, 104), (50, 105), (51, 106), (52, 107), (53, 108), (54, 109)]\n",
        "# ,2: [(0, 21), (1, 22), (2, 23), (3, 24), (4, 25), (5, 26), (6, 27), (7, 28), (8, 29), (9, 30), (10, 31), (11, 32), (12, 33), (13, 34), (14, 35), (15, 36), (16, 37), (17, 38), (18, 39), (19, 40), (20, 41), (0, 63), (1, 64), (2, 65), (3, 66), (4, 67), (5, 68), (6, 69), (7, 70), (0, 79), (1, 80), (2, 81), (0, 85), (0, 89), (1, 90), (2, 91), (3, 92), (4, 93), (5, 94), (6, 95), (7, 96), (8, 97), (9, 98), (10, 99), (11, 100), (12, 101), (13, 102), (14, 103), (15, 104), (16, 105), (17, 106), (18, 107), (19, 108), (20, 109), (21, 110), (22, 111), (23, 112), (24, 113), (25, 114), (26, 115), (27, 116), (28, 117), (29, 118), (30, 119), (31, 120), (32, 121), (33, 122), (34, 123), (35, 124), (36, 125), (37, 126), (38, 127), (39, 128), (40, 129), (41, 130), (42, 131), (43, 132), (44, 133), (45, 134), (46, 135), (47, 136), (48, 137), (49, 138), (50, 139), (51, 140), (52, 141), (53, 142), (54, 143)]}\n",
        "pl = PluckerRelations(representation, dim_I, dim_J)\n",
        "working_dir = \"C://Users//riley//Research//\"\n",
        "filename = \"tree_P_(\"+str(pl.dim1)+\", \"+str(pl.dim2)+\"),\"+\"(\"+str(dim_I)+\", \"+str(dim_J)+\").tex\"\n",
        "TeX_doc = open(working_dir+filename,'w')\n",
        "TeX_doc.write(\"\\\\documentclass{amsart}\\n\\\\usepackage[margin=0.3in]{geometry}\\n\\\\usepackage[rgb]{xcolor}\\n\\\\usepackage{pdflscape, amsmath,amssymb,latexsym,xcolor, tikz, hyperref, mdframed}\\n\\n\")\n",
        "TeX_doc.write(\"\\\\newcommand{\\\\CC}{\\\\mathbb{C}}\\n\")\n",
        "TeX_doc.write(\"\\\\newcommand{\\\\doublearrow}{\\\\substack{\\\\leftarrow\\\\\\\\ \\\\leftarrow}}\\n\\n\")\n",
        "TeX_doc.write(\"\\\\hypersetup{colorlinks=true, linkcolor=blue}\\n\")\n",
        "TeX_doc.write(\"\\\\title{Plucker Relations}\\n\")\n",
        "TeX_doc.write(\"\\\\author{Riley Paddock}\\n\")\n",
        "TeX_doc.write(\"\\\\begin{document}\\n\\n\")\n",
        "TeX_doc.write(\"\\\\maketitle\\n\\n\")\n",
        "\n",
        "TeX_doc.write(\"\\\\begin{landscape}\\n\\\\section[Grassmanian]{$Gr_{\"+str((dim_J,dim_I))+\"}(\\\\CC^{\"+str(pl.dim2)+\"}\\\\leftarrow\\\\CC^{\"+str(pl.dim1)+\"})$}\\n\")\n",
        "\n",
        "# compatible_pairs = []\n",
        "# S_1 = [1,12,42,53]\n",
        "# S_2 = []\n",
        "# for key in representation:\n",
        "#     for s in S_1:\n",
        "#         for i in range(56):\n",
        "#             if representation[key][-i][0] == s:\n",
        "#                 S_2.append(representation[key][-i][1])\n",
        "\n",
        "S_1 = [0,2,6,11,13,36,41,43,47,52,54]\n",
        "S_2 = [0, 2, 6, 11, 13, 36, 41, 43, 47, 52, 54, 56, 58, 62, 67, 69, 82, 84, 85, 92, 97, 99, 103, 108, 110, 112, 114, 118, 123, 125, 139, 146, 148, 153, 155, 159, 164, 166, 189, 194, 196, 200, 205, 207]\n",
        "#extra = 83,84,120,121,122\n",
        "data = generate_schubert_cell_data(pl,S_1,S_2, dim1, dim2, [len(S_1),len(S_2)], n)\n",
        "\n",
        "\n",
        "D,A,B,C = DABC(n,t,representation, S_1,S_2)\n",
        "TeX_doc.write(tex_DABC(D,A,B,C))\n",
        "TeX_doc.write(generate_cell_TeX(data))\n",
        "TeX_doc.write(\"\\\\end{document}\")\n",
        "TeX_doc.close()\n",
        "print('complete: '+str(time.time()-start))"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "6iz3yOahTWnM"
      },
      "outputs": [],
      "source": []
    }
  ],
  "metadata": {
    "kernelspec": {
      "display_name": "Python 3",
      "language": "python",
      "name": "python3"
    },
    "language_info": {
      "codemirror_mode": {
        "name": "ipython",
        "version": 3
      },
      "file_extension": ".py",
      "mimetype": "text/x-python",
      "name": "python",
      "nbconvert_exporter": "python",
      "pygments_lexer": "ipython3",
      "version": "3.11.9"
    },
    "colab": {
      "provenance": []
    }
  },
  "nbformat": 4,
  "nbformat_minor": 0
}